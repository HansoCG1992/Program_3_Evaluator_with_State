# Machine-Generated Code Included in Program
# Created By: Cole Hanson

- **Course:** CS 441 - Programming Languages
- **Assignment:** Program 3 - Expression Evaluator with State
-  *LLM Used:** Claude 4.5 Sonnet (via Claude.ai)

This document contains all machine-generated code that was included in the final program, either used directly or with minor modifications.

---

## 1. Either/Result Type System

- **Source:** Generated by Claude (Prompt 1)
- **Status:** Used verbatim
- **Location in evaluator.rkt:** Lines 15-42

```racket
;; ============================================================================
;; EITHER/RESULT TYPE SYSTEM
;; ============================================================================

;; Define result constructors
(define (success value)
  (list 'success value))

(define (failure message)
  (list 'failure message))

;; Type predicates
(define (success? result)
  (and (list? result)
       (not (null? result))
       (equal? (first result) 'success)))

(define (failure? result)
  (and (list? result)
       (not (null? result))
       (equal? (first result) 'failure)))

;; Extract value from result, with default
(define (from-success default result)
  (if (success? result)
      (second result)
      default))

(define (from-failure default result)
  (if (failure? result)
      (second result)
      default))
```

---

## 2. Safe Division with Either

**Source:** Generated by Claude (Prompt 2)
**Status:** Used verbatim
**Location in evaluator.rkt:** Lines 108-112

```racket
(define (safe-div x y)
  (if (= y 0)
      (failure "division by zero")
      (success (/ x y))))
```

---

## 3. State Management Functions

**Source:** Generated by Claude (Prompts 3-4)
**Status:** Used verbatim
**Location in evaluator.rkt:** Lines 51-104

```racket
;; ============================================================================
;; STATE MANAGEMENT
;; ============================================================================

;; State is an immutable association list of (id . value) pairs
;; value can be 'undefined or an actual number

(define empty-state '())

;; Special undefined marker
(define UNDEFINED 'undefined)

;; Check if identifier exists in state
(define (id-exists? id state)
  (if (assoc id state) #t #f))

;; Get value of identifier from state
(define (get-id-value id state)
  (let ([binding (assoc id state)])
    (if binding
        (cdr binding)
        #f)))

;; Add new identifier to state (must not exist)
(define (add-id id value state)
  (if (id-exists? id state)
      #f  ; ID already exists
      (cons (cons id value) state)))

;; Update existing identifier in state
(define (update-id id value state)
  (cond
    [(null? state) #f]  ; ID not found
    [(equal? (caar state) id)
     (cons (cons id value) (cdr state))]
    [else
     (let ([rest (update-id id value (cdr state))])
       (if rest
           (cons (car state) rest)
           #f))]))

;; Remove identifier from state
(define (remove-id id state)
  (cond
    [(null? state) #f]  ; ID not found
    [(equal? (caar state) id) (cdr state)]
    [else
     (let ([rest (remove-id id (cdr state))])
       (if rest
           (cons (car state) rest)
           #f))]))
```

---

## 4. Identifier Validation

**Source:** Generated by Claude (Prompt 5)
**Status:** Used verbatim
**Location in evaluator.rkt:** Lines 88-97

```racket
;; Check if a symbol is a valid identifier
;; Must start with letter, followed by letters, digits, hyphens, underscores
(define (valid-id? sym)
  (and (symbol? sym)
       (let ([str (symbol->string sym)])
         (and (> (string-length str) 0)
              (char-alphabetic? (string-ref str 0))
              (andmap (λ (c) (or (char-alphabetic? c)
                                  (char-numeric? c)
                                  (equal? c #\-)
                                  (equal? c #\_)))
                      (string->list str))))))
```

---

## 5. Expression Evaluator - NUM Handler

**Source:** Generated by Claude (Prompt 6)
**Status:** Used verbatim
**Location in evaluator.rkt:** Lines 124-129

```racket
    ;; ---- NUM: numeric literal ----
    [(and (list? expr)
          (not (null? expr))
          (equal? (first expr) 'num))
     (if (and (= (length expr) 2) (number? (second expr)))
         (cons (success (second expr)) state)
         (cons (failure "num: invalid syntax") state))]
```

---

## 6. Expression Evaluator - ID Handler

**Source:** Generated by Claude (Prompt 7)
**Status:** Used verbatim
**Location in evaluator.rkt:** Lines 131-148

```racket
    ;; ---- ID: variable reference ----
    [(and (list? expr)
          (not (null? expr))
          (equal? (first expr) 'id))
     (if (not (= (length expr) 2))
         (cons (failure "id: invalid syntax") state)
         (let ([id-name (second expr)])
           (if (not (valid-id? id-name))
               (cons (failure (format "id: '~a' is not a valid identifier" id-name)) state)
               (let ([value (get-id-value id-name state)])
                 (cond
                   [(not value)
                    (cons (failure (format "id ~a: identifier not defined" id-name)) state)]
                   [(equal? value UNDEFINED)
                    (cons (failure (format "id ~a: identifier is undefined" id-name)) state)]
                   [else
                    (cons (success value) state)])))))]
```

---

## 7. Expression Evaluator - DEFINE Handler

**Source:** Generated by Claude (Prompt 8)
**Status:** Used verbatim
**Location in evaluator.rkt:** Lines 150-174

```racket
    ;; ---- DEFINE: create new variable ----
    [(and (list? expr)
          (not (null? expr))
          (equal? (first expr) 'define))
     (cond
       [(< (length expr) 2)
        (cons (failure "define: missing identifier") state)]
       [(> (length expr) 3)
        (cons (failure "define: too many arguments") state)]
       [else
        (let ([id-name (second expr)])
          (if (not (valid-id? id-name))
              (cons (failure (format "define: '~a' is not a valid identifier" id-name)) state)
              (if (id-exists? id-name state)
                  (cons (failure (format "define ~a: identifier already defined" id-name)) state)
                  (if (= (length expr) 2)
                      ;; define without value -> undefined
                      (let ([new-state (add-id id-name UNDEFINED state)])
                        (cons (success id-name) new-state))
                      ;; define with value expression
                      (let* ([value-result (eval-expr (third expr) state)]
                             [result (car value-result)]
                             [result-state (cdr value-result)])
                        (if (failure? result)
                            (cons result state)  ; propagate failure, don't modify state
                            (let ([new-state (add-id id-name (from-success 0 result) state)])
                              (cons (success id-name) new-state))))))))])]
```

---

## 8. Expression Evaluator - ASSIGN Handler

**Source:** Generated by Claude (Prompt 9)
**Status:** Used verbatim
**Location in evaluator.rkt:** Lines 176-199

```racket
    ;; ---- ASSIGN: assign value to existing undefined variable ----
    [(and (list? expr)
          (not (null? expr))
          (equal? (first expr) 'assign))
     (if (not (= (length expr) 3))
         (cons (failure "assign: invalid syntax (expected: assign id expr)") state)
         (let ([id-name (second expr)])
           (if (not (valid-id? id-name))
               (cons (failure (format "assign: '~a' is not a valid identifier" id-name)) state)
               (let ([current-value (get-id-value id-name state)])
                 (cond
                   [(not current-value)
                    (cons (failure (format "assign ~a: identifier not defined" id-name)) state)]
                   [(not (equal? current-value UNDEFINED))
                    (cons (failure (format "assign ~a: identifier already has a value (data is immutable)" id-name)) state)]
                   [else
                    ;; evaluate the expression
                    (let* ([value-result (eval-expr (third expr) state)]
                           [result (car value-result)]
                           [result-state (cdr value-result)])
                      (if (failure? result)
                          (cons result state)  ; propagate failure
                          (let ([new-state (update-id id-name (from-success 0 result) state)])
                            (if new-state
                                (cons (success id-name) new-state)
                                (cons (failure (format "assign ~a: update failed" id-name)) state)))))])))))]
```

---

## 9. Expression Evaluator - REMOVE Handler

**Source:** Generated by Claude (Prompt 10)
**Status:** Used verbatim
**Location in evaluator.rkt:** Lines 201-212

```racket
    ;; ---- REMOVE: remove variable from state ----
    [(and (list? expr)
          (not (null? expr))
          (equal? (first expr) 'remove))
     (if (not (= (length expr) 2))
         (cons (failure "remove: invalid syntax") state)
         (let ([id-name (second expr)])
           (if (not (valid-id? id-name))
               (cons (failure (format "remove: '~a' is not a valid identifier" id-name)) state)
               (if (not (id-exists? id-name state))
                   (cons (failure (format "remove ~a: identifier not defined" id-name)) state)
                   (let ([new-state (remove-id id-name state)])
                     (cons (success id-name) new-state))))))]
```

---

## 10. Expression Evaluator - Arithmetic Operations (Core Structure)

**Source:** Generated by Claude (Prompt 6)
**Status:** Modified - added state threading fix (Prompt 13) and type guards (Prompt 14)
**Location in evaluator.rkt:** Lines 214-255

```racket
    ;; ---- ARITHMETIC OPERATIONS ----
    [(and (list? expr)
          (not (null? expr))
          (member (first expr) '(add sub mult div)))
     (if (not (= (length expr) 3))
         (cons (failure (format "~a: invalid syntax (expected 2 operands)" (first expr))) state)
         (let* ([op (first expr)]
                [left-result (eval-expr (second expr) state)]
                [left-val (car left-result)]
                [left-state (cdr left-result)])
           (if (failure? left-val)
               (cons left-val state)  ; propagate failure, rollback to original state
               (let* ([right-result (eval-expr (third expr) left-state)]  ; MODIFIED: thread state forward
                      [right-val (car right-result)]
                      [right-state (cdr right-result)])
                 (if (failure? right-val)
                     (cons right-val state)  ; propagate failure, rollback to original state
                     (let ([x (from-success 0 left-val)]
                           [y (from-success 0 right-val)])
                       ;; MODIFIED: Type guard added per Prompt 14
                       (if (not (and (number? x) (number? y)))
                           (cons (failure (format "~a: operands must be numeric" op)) state)
                           (cons
                            (cond
                              [(equal? op 'add) (success (+ x y))]
                              [(equal? op 'sub) (success (- x y))]
                              [(equal? op 'mult) (success (* x y))]
                              [(equal? op 'div) (safe-div x y)])
                            right-state))))))))]  ; MODIFIED: return right-state
```

**Modifications Made:**
- Line 239: Changed from `state` to `left-state` to thread state forward
- Lines 246-248: Added type guard to prevent Racket exceptions
- Line 255: Changed from `state` to `right-state` to return final state

---

## 11. REPL Loop Structure

**Source:** Generated by Claude (Prompt 11)
**Status:** Used verbatim
**Location in evaluator.rkt:** Lines 286-308

```racket
;; Main REPL loop
(define (repl [state empty-state])
  (display "\n> ")
  (flush-output)
  (let ([input (read)])
    (cond
      [(eof-object? input)
       (displayln "\nGoodbye!")
       (void)]
      [(or (equal? input 'quit) (equal? input 'exit) (equal? input 'q))
       (displayln "Goodbye!")
       (void)]
      [(equal? input 'state)
       (print-state state)
       (repl state)]
      [(equal? input 'help)
       (displayln "Commands:")
       (displayln "  [... help text ...]")
       (repl state)]
      [else
       (let* ([result-pair (eval-expr input state)]
              [result (car result-pair)]
              [new-state (cdr result-pair)])
         (print-result result)
         (when (failure? result)
           (displayln "  State unchanged"))
         (repl new-state))])))
```

---

## 12. State and Result Printing Functions

**Source:** Generated by Claude (Prompt 12)
**Status:** Used verbatim
**Location in evaluator.rkt:** Lines 265-283

```racket
;; Print the current state in a readable format
(define (print-state state)
  (if (null? state)
      (displayln "  State: (empty)")
      (begin
        (displayln "  State:")
        (for-each (λ (binding)
                    (let ([id (car binding)]
                          [val (cdr binding)])
                      (if (equal? val UNDEFINED)
                          (displayln (format "    ~a = <undefined>" id))
                          (displayln (format "    ~a = ~a" id val)))))
                  state))))

;; Print a result
(define (print-result result)
  (if (success? result)
      (displayln (format "  Success: ~a" (from-success 0 result)))
      (displayln (format "  Error: ~a" (from-failure "" result)))))
```

---

## 13. Test Framework Structure

**Source:** Generated by Claude (Prompt 15)
**Status:** Used as template, expanded with additional tests
**Location in evaluator.rkt:** Lines 310-420 (approx)

```racket
(displayln "=== Running Initial Tests ===\n")

(displayln "Test 1: (num 5)")
(let ([result (eval-expr '(num 5) empty-state)])
  (print-result (car result))
  (print-state (cdr result)))

(displayln "\nTest 2: (add (num 5) (mult (num 2) (num 3)))  ; 5 + (2*3) = 11")
(let ([result (eval-expr '(add (num 5) (mult (num 2) (num 3))) empty-state)])
  (print-result (car result))
  (print-state (cdr result)))

;; [Additional tests added by me]
```

---

## Summary of Machine-Generated Code

### Code Used Verbatim (No Modifications):
1. ✅ Either/Result type system (complete)
2. ✅ Safe division function
3. ✅ All state management functions
4. ✅ Identifier validation
5. ✅ NUM expression handler
6. ✅ ID expression handler
7. ✅ DEFINE expression handler
8. ✅ ASSIGN expression handler
9. ✅ REMOVE expression handler
10. ✅ REPL loop structure
11. ✅ Print functions (state and result)
12. ✅ Test framework structure

### Code Used with Modifications:
1. ⚠️ **Arithmetic operations** - Added:
   - State threading fix (left-state → right-result, return right-state)
   - Type guards for numeric operands
   - Original structure from Claude, fixes applied based on Claude's guidance

### Code I Wrote Myself (~25%):
1. Extended arithmetic pattern to sub, mult, div (after Claude showed add)
2. Help command text content
3. Additional test cases (Claude gave framework, I added 16 comprehensive tests)
4. Documentation files (README, IMPLEMENTATION_GUIDE, USAGE_EXAMPLES)
5. Code organization and comments
6. Bug fixes based on testing

### Percentage Breakdown:
- **~75% Machine-Generated:** Core functionality, data structures, evaluator logic
- **~25% Human-Written:** Extensions, documentation, testing, refinements

---

## Notes on Usage

All machine-generated code listed above was:
- Generated via Claude 4.5 Sonnet (Claude.ai)
- Prompted with specific requirements based on assignment spec
- Tested and verified for correctness
- Integrated into final program with or without modification
- Used with understanding of functionality and purpose

This code represents the complex/difficult portions of the assignment that required LLM assistance to implement correctly, particularly the functional state threading semantics and Either/Result error handling patterns.
